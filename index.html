<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fully Featured Sudoku</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
        }

        h1 {
            margin-bottom: 10px;
        }

        #sudoku-grid {
            display: grid;
            grid-template-columns: repeat(9, 40px);
            grid-gap: 1px;
            background-color: #000;
            padding: 1px;
            margin: 20px;
        }

        .cell {
            width: 40px;
            height: 40px;
            background-color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            border: none;
            text-align: center;
        }

        .cell.readonly {
            background-color: #e0e0e0;
        }

        .cell.error {
            background-color: #ffcccc;
        }

        .cell:nth-child(3n) {
            border-right: 2px solid #000;
        }

        .cell:nth-child(27n + 1),
        .cell:nth-child(27n + 2),
        .cell:nth-child(27n + 3),
        .cell:nth-child(27n + 4),
        .cell:nth-child(27n + 5),
        .cell:nth-child(27n + 6),
        .cell:nth-child(27n + 7),
        .cell:nth-child(27n + 8),
        .cell:nth-child(27n + 9) {
            border-bottom: 2px solid #000;
        }

        .controls {
            display: flex;
            justify-content: center;
            margin-bottom: 10px;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            margin: 5px;
            cursor: pointer;
        }

        #timer {
            font-size: 18px;
            margin-top: 10px;
        }

        #difficulty {
            padding: 5px;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <h1>Sudoku</h1>
    <div class="controls">
        <select id="difficulty">
            <option value="easy">Easy</option>
            <option value="medium">Medium</option>
            <option value="hard">Hard</option>
        </select>
        <button onclick="newGame()">New Game</button>
        <button onclick="solvePuzzle()">Solve</button>
        <button onclick="getHint()">Hint</button>
        <button onclick="undo()">Undo</button>
        <button onclick="redo()">Redo</button>
    </div>
    <div id="sudoku-grid"></div>
    <div id="timer">Time: 0:00</div>

    <script>
        const grid = document.getElementById('sudoku-grid');
        let puzzle = Array(9).fill().map(() => Array(9).fill(0));
        let solution = Array(9).fill().map(() => Array(9).fill(0));
        let history = [];
        let redoStack = [];
        let timerInterval;
        let seconds = 0;

        // Initialize the grid
        function createGrid() {
            grid.innerHTML = '';
            for (let i = 0; i < 9; i++) {
                for (let j = 0; j < 9; j++) {
                    const cell = document.createElement('input');
                    cell.classList.add('cell');
                    cell.type = 'text';
                    cell.maxLength = 1;
                    cell.addEventListener('input', (e) => handleInput(e, i, j));
                    cell.addEventListener('focus', () => cell.select());
                    grid.appendChild(cell);
                }
            }
        }

        // Handle user input
        function handleInput(e, row, col) {
            const value = e.target.value;
            if (value && !/^[1-9]$/.test(value)) {
                e.target.value = '';
                return;
            }
            history.push({ row, col, value: puzzle[row][col] });
            redoStack = [];
            puzzle[row][col] = value ? parseInt(value) : 0;
            updateGrid();
            saveGame();
        }

        // Update grid with puzzle values
        function updateGrid() {
            const cells = document.querySelectorAll('.cell');
            cells.forEach((cell, index) => {
                const row = Math.floor(index / 9);
                const col = index % 9;
                cell.value = puzzle[row][col] || '';
                cell.classList.toggle('readonly', solution[row][col] !== 0);
                cell.readOnly = solution[row][col] !== 0;
                cell.classList.remove('error');
                if (puzzle[row][col] && puzzle[row][col] !== solution[row][col]) {
                    cell.classList.add('error');
                }
            });
        }

        // New Game
        function newGame() {
            const difficulty = document.getElementById('difficulty').value;
            generatePuzzle(difficulty);
            history = [];
            redoStack = [];
            seconds = 0;
            clearInterval(timerInterval);
            timerInterval = setInterval(updateTimer, 1000);
            updateGrid();
            saveGame();
        }

        // Generate a new puzzle
        function generatePuzzle(difficulty) {
            solution = generateFullGrid();
            puzzle = solution.map(row => row.slice());
            const cellsToRemove = { easy: 40, medium: 50, hard: 60 }[difficulty];
            removeNumbers(puzzle, cellsToRemove);
        }

        // Generate a full Sudoku grid
        function generateFullGrid() {
            const grid = Array(9).fill().map(() => Array(9).fill(0));
            solveSudoku(grid);
            return grid;
        }

        // Remove numbers from the grid
        function removeNumbers(grid, count) {
            let attempts = count;
            while (attempts > 0) {
                let row = Math.floor(Math.random() * 9);
                let col = Math.floor(Math.random() * 9);
                while (grid[row][col] === 0) {
                    row = Math.floor(Math.random() * 9);
                    col = Math.floor(Math.random() * 9);
                }
                const backup = grid[row][col];
                grid[row][col] = 0;
                const tempGrid = grid.map(row => row.slice());
                if (!hasUniqueSolution(tempGrid)) {
                    grid[row][col] = backup;
                } else {
                    attempts--;
                }
            }
        }

        // Check if the grid has a unique solution
        function hasUniqueSolution(grid) {
            let solutions = 0;
            function countSolutions(board) {
                let empty = findEmpty(board);
                if (!empty) {
                    solutions++;
                    return solutions > 1;
                }
                let [row, col] = empty;
                for (let num = 1; num <= 9; num++) {
                    if (isValid(board, num, row, col)) {
                        board[row][col] = num;
                        if (countSolutions(board)) return true;
                        board[row][col] = 0;
                    }
                }
                return false;
            }
            countSolutions(grid.map(row => row.slice()));
            return solutions === 1;
        }

        // Solve the puzzle
        function solvePuzzle() {
            puzzle = solution.map(row => row.slice());
            updateGrid();
            clearInterval(timerInterval);
        }

        // Get a hint
        function getHint() {
            const emptyCells = [];
            for (let i = 0; i < 9; i++) {
                for (let j = 0; j < 9; j++) {
                    if (puzzle[i][j] === 0) {
                        emptyCells.push([i, j]);
                    }
                }
            }
            if (emptyCells.length > 0) {
                const [row, col] = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                puzzle[row][col] = solution[row][col];
                updateGrid();
                saveGame();
            }
        }

        // Undo last move
        function undo() {
            if (history.length > 0) {
                const lastMove = history.pop();
                redoStack.push({ row: lastMove.row, col: lastMove.col, value: puzzle[lastMove.row][lastMove.col] });
                puzzle[lastMove.row][lastMove.col] = lastMove.value;
                updateGrid();
                saveGame();
            }
        }

        // Redo last undone move
        function redo() {
            if (redoStack.length > 0) {
                const nextMove = redoStack.pop();
                history.push({ row: nextMove.row, col: nextMove.col, value: puzzle[nextMove.row][nextMove.col] });
                puzzle[nextMove.row][nextMove.col] = nextMove.value;
                updateGrid();
                saveGame();
            }
        }

        // Timer functions
        function updateTimer() {
            seconds++;
            const minutes = Math.floor(seconds / 60);
            const secs = seconds % 60;
            document.getElementById('timer').textContent = `Time: ${minutes}:${secs < 10 ? '0' : ''}${secs}`;
        }

        // Save game state
        function saveGame() {
            localStorage.setItem('sudokuPuzzle', JSON.stringify(puzzle));
            localStorage.setItem('sudokuSolution', JSON.stringify(solution));
            localStorage.setItem('sudokuHistory', JSON.stringify(history));
            localStorage.setItem('sudokuRedoStack', JSON.stringify(redoStack));
            localStorage.setItem('sudokuSeconds', seconds);
        }

        // Load game state
        function loadGame() {
            const savedPuzzle = localStorage.getItem('sudokuPuzzle');
            if (savedPuzzle) {
                puzzle = JSON.parse(savedPuzzle);
                solution = JSON.parse(localStorage.getItem('sudokuSolution'));
                history = JSON.parse(localStorage.getItem('sudokuHistory'));
                redoStack = JSON.parse(localStorage.getItem('sudokuRedoStack'));
                seconds = parseInt(localStorage.getItem('sudokuSeconds'));
                updateGrid();
                timerInterval = setInterval(updateTimer, 1000);
            } else {
                newGame();
            }
        }

        // Sudoku solving functions
        function solveSudoku(board) {
            let empty = findEmpty(board);
            if (!empty) return true;
            let [row, col] = empty;
            for (let num = 1; num <= 9; num++) {
                if (isValid(board, num, row, col)) {
                    board[row][col] = num;
                    if (solveSudoku(board)) return true;
                    board[row][col] = 0;
                }
            }
            return false;
        }

        function findEmpty(board) {
            for (let i = 0; i < 9; i++) {
                for (let j = 0; j < 9; j++) {
                    if (board[i][j] === 0) return [i, j];
                }
            }
            return null;
        }

        function isValid(board, num, row, col) {
            for (let x = 0; x < 9; x++) {
                if (board[row][x] === num || board[x][col] === num) return false;
            }
            let startRow = row - row % 3, startCol = col - col % 3;
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    if (board[i + startRow][j + startCol] === num) return false;
                }
            }
            return true;
        }

        // Start the game
        createGrid();
        loadGame();
    </script>
</body>
</html>
